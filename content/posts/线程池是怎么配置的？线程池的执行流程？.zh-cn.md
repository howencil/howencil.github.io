---
title: "线程池是怎么配置的？线程池的执行流程？"
date: 2022-06-07T10:31:14+08:00
draft: false
author: 插画师
tags: ["Java"]
categories: ["Tech"]
---

## 1.线程池如何配置
1. 线程池的主要参数：
	1. 核心线程数
	2. 最大线程数
	3. 空闲时间
	4. 时间单位
	5. 拒绝策略
	6. 任务队列

2. 核心线程数量大小选择
	
	| 看业务选择
	
	1. CPU密集型：核心数 + 1
	2. IO密集型：CPU核心数 * 2
	
3. 线程池参数动态化
	*我们最应该关心的参数是corePoolSize核心线程数、maximumPoolSize最大线程数、workQueue队列长度，
	我们可以使用Apollo来动态修改线程池的参数。*
## 2.线程池的执行流程
1. 任务执行机制
	1. 首先检测线程运行状态，如果不是RUNNING，则直接拒绝，线程要保证在RUNNING状态下执行任务。
	2. 如果workerCount < corePoolSize，则创建一个线程来执行新提交的任务。
	3. 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
	4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
	5. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛出异常。
	6. ![](/线程池是怎么配置的？线程池的执行流程？/20220519044007.png)

## 3.关于线程池的2个问题
1. 如果线程池接受到了30个比较耗时的任务，这时候线程池的状态是怎么样的？
2. 在前面30个耗时任务的还没执行完的情况下，再来多少个任务会触发拒绝策略？

- 关于第1个问题：当接收到了30个比较耗时的任务时，10个核心线程都在工作，剩下的20个任务会去队列里排队等候。这个时候和**最大线程数量**是没有关系的，所以和**空闲时间**这个参数也没有关系。
- 关于第2个问题：当了解了第1个问题的答案，那么第2个问题也就好解释了。比如说线程池最大课接收**1000（队列长度）+30（最大线程数）=1030个任务**。所以当接收30个比较耗时的任务时，再来1000个比较耗时的任务，此时队列也满了，最大线程数的线程也都在工作，那么线程池就满载了。因此在30个任务都还没执行完的情况下，*第1001个任务就会触发拒绝策略*。

## 4.对于线程池如何设置参数而引出的几个问题
1. 现有的解决方案的痛点。
2. 动态更新的工作原理是什么？
3. 动态设置需要注意哪些地方？
4. 如何动态指定队列的长度？
5. 这个过程中涉及到的面试题有哪些？

###### 1.现有解决方案的痛点
现在一般把线程池中的任务分为2种，**CPU密集型**和**IO密集型**。
- CPU密集型：CPU核心数+1。为什么要加1呢？引用《Java并发编程实战》一书中给出的原因是：==即使当计算（CPU）密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个"额外"的线程也能确保CPU的时钟周期不会被浪费。==可以把它理解为一个备份的线程就好了。
- IO密集型：一般是给出CPU核心数 * 2

###### 2.动态更新的工作原理是什么？
举个例子，一个线程池的核心线程数是2，最大线程数是5，队列长度是10。这个时候来了15个耗时10秒的任务，此时5个最大线程在工作，10个任务在队列里。可以算出来，*一共需要3个10秒来完全执行这15个任务。*
如果这个时候将核心线程数和最大线程数都修改为10，那可以前10个任务会在10秒内执行完毕，后5个也将在10秒内执行完毕。*总共需要2个10秒来完全执行这15个任务。*
- setCorePoolSize方法：**在线程池执行期间调用此方法设设置corePoolSize后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的策略。**
	- 如果当前值小于当前工作线程：说明有多余的worker线程，此时如果存在==空闲==的线程，会向其发起中断情况以实现回收。其他多余的worker线程也会在==空闲==时被回收。
	- 如果当前值大于原始值并且队列中存在任务，则线程池会创建新的worker线程来执行队列中的任务。
	- ![](/线程池是怎么配置的？线程池的执行流程？/20220520100715.png)

- setMaximumPoolSize方法：**1.首先是校验参数的合法性；2.然后入参覆盖原始值；3.判断工作线程是否大于最大线程数，如果大于，就会对==空闲==线程发起中断请求并回收。**

###### 3.动态设置需要注意哪些地方？
- 一个线程池：核心线程数是2，最大线程数是5，动态修改核心线程数为10并且调用prestartAllCoreThreads方法（*该方法会启动所有的核心线程*）。但在运行时，活跃的线程数还是5。
- 这个地方实际的工作流程是：
	- 1.创建新的工作线程worker，然后工作线程数进行加1操作；
	- 2.运行创建的工作线程worker，开始获取任务task；
	- 3.工作线程数量大于最大线程数量，对工作线程数进行-1操作；
	- 4.返回null，即没有获取到task；
	- 5.清理该任务，流程结束。

	如何解决这个问题呢？**设置核心线程数的同时设置最大线程数，一般讲两者设置为相同的值。**
	还有个问题，如果调整之后把活跃的线程数设置得太大了，在业务低峰期还需要人工调小吗？答案是**不需要，当allowCoreThreadTimeOut设置为true时，核心线程在空闲了keepAliveTime的时间后也会被回收，相当于线程池给你动态修改了。**

###### 4.如何动态指定队列长度？
关于队列，并没有提供set方法，因为队列的capacity是被final修饰的。那如何动态调整呢？
- 可以自定义队列，让其可以对capacity参数进行修改。操作起来也很简单，**把LinkedBlockingQueue复制一份，修改个名字，把capacity的final修饰符去掉，并且提供get/set方法，然后在程序里把原来的队列替换掉。**
- ![](/线程池是怎么配置的？线程池的执行流程？/20220520103940.png)
- ![](/线程池是怎么配置的？线程池的执行流程？/20220520103946.png)

###### 5.这个过程中涉及到的面试题有哪些？
1. 如何对线程池进行预热？
	1. 全部启动：prestartAllCoreThreads()方法
	2. 仅启动一个：prestartCoreThread()方法
2. 核心线程数会被回收吗？如何设置？
	1. 核心线程数默认不会被回收，但如果要回收核心线程数可以调用allowCoreThreadTimeOut方法，该方法默认为false，将其设置为true即可。

**参考文章：**

> 1.[如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。 - why技术 - 博客园](https://www.cnblogs.com/thisiswhy/p/12690630.html)
>
> 2.[Java线程池实现原理及其在美团业务中的实践 - 美团技术团队](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
