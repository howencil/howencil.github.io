---
title: "Hashmap的原理？hashmap为什么用红黑树？"
date: 2022-06-07T15:07:41+08:00
draft: false
author: 插画师
tags: ["Java"]
categories: ["Tech"]
---

## 1.数据结构
**数组+链表/红黑树**
![](/hashmap的原理？hashmap为什么用红黑树？/1.png)

###### 1.什么是Node
- HashMap类有一个非常重要的属性Node<K,V>，是HashMap的一个内部类，实现了Entry接口，本质上是一个映射。
###### 2.为什么会出现一个链表
- 可以把图中的数组看成一个一个桶，当map进行put()操作时，会进行hash计算，判定这个对象属于哪个桶，当多于一个对象属于同一个桶，就称之为hash冲突，多个对象就形成了链表。
###### 3.为什么JDK8会引入红黑树，为什么一直用红黑树呢？
- 当链表长度大于8时，遍历查找效率较慢，所以引入红黑树。因为红黑树在插入新数据之后，可能会通过左旋、右旋、变色来保持平衡，所以当链路较短时不合适用红黑树。

## 2.数组扩容的原理
**当插入数据，发现当前map大小超过阈值（capacity * loadFactory，便会创建一个新的数组，新的数组大小是原来数组的2倍，信的数组下标为原先数组的下标或者原先数组下标+旧数组的大小。**
###### 1.HashMap的容量为什么总是capacity的2次幂？
- 当计算数组下标时，如图所示
- !![](/hashmap的原理？hashmap为什么用红黑树？/2.png)
- 因为n永远是2的次幂，所以n-1通过二进制表示，永远都是尾端以连续1的形式表示（00001111，00000011）当(n-1)和hash做与运算时，会保留hash中后x位的1，例如* 例如 00001111 & 10000011 = 00000011*。
	- &运算快，至少比%取模运算快；
	- 能保证索引值肯定在capacity中，不会超出数组长度；
	- (n-1) & hash，当n为2次幂时 ，会满足一个公式：*(n-1) & hash = hash % n*。

###### 2.HashMap的hash算法
```Java
static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); }	
```
先获取key的hashcode值h，然后h和右移16位做异或运算即一个数的低16位和它的高16位做异或运算，减少hash冲突。
- HashMap的put原理
	- 1.如果key是null，则放入table[0]；
	- 2.获取key的hash值计算下标，找到对应的目标桶；
	- 3.如果目标桶有链表，遍历Entry结点，用equals()判断，true则更新覆盖值，false则用尾插法将对象放入链表后面。如果目标桶是树结构，则转为红黑树做插入操作。若未找到目标Entry结点，则新增一个Entry节点，放入值后返回null。
	- 4.如果此时添加的元素超过Treeify threshold则进行扩容。

- HashMap的get原理
	- 1.获取key的hash值计算下标，找到对应的桶；
	- 2.遍历链表，用equals()方法判断，为true则返回值
	- 3.否则返回null。

- hashmap，linkedhashmap，treemap，hashtable之间的区别
	- 1.HashMap线程不安全，允许1个key为null，允许多个value为null；
	- 2.LinkedHashMap能保留put键值对的顺序；
	- 3.TreeMap实现了SortMap接口，默认对put的键值对进行key排序；
	- 4.HashTable线程安全，所有方法用synchronize修饰过，不允许key或value为null。

###### 3.简单说说ConcurrentHashMap
1. 相对于HashMap，concurrentHashMap是线程安全的，使用了Node+CAS+synchronize来保证线程安全，锁的颗粒度较小。

###### 4.为什么不直接将key作为哈希值而是与高16位做异或运算？
因为数组位置的确定使用的是与运算，仅仅最后4位有效，设计者将key的哈希值与高16位做异或运算使得在与运算确定数组的插入位置时此时的低位是高位与低位的结合，增加了随机性，减少了哈希碰撞的次数。HashMap默认初始化长度为16，并且每次自动或者手动扩容时，必须是2的幂。

###### 5.为什么HashMap的初始值是16，为什么必须是2的幂？如果输入值不是2的幂，比如10会怎么样？
1. 为了数据的均匀分布，减少哈希碰撞。因为确定数组位置用的是位运算，如果数据不是2的次幂则会增加哈希碰撞的次数和浪费数组空间。（*如果不用考虑效率，其实不是求余也可以，也就是不用位运算了长度也可随意设置。*）
2. 输入数据不是2的次幂，HashMap通过移运算和或运算得到的肯定是2的幂次数，并且是最接近那个数的数字。

###### 6.HashMap为什么是线程不安全的？
多线程下对HashMap进行添加、删除、修改都可能会造成数据覆盖。
