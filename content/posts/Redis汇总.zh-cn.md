---
title: "Redis汇总"
date: 2022-06-20T15:36:25+08:00
draft: false
author: 插画师
tags: ["Redis"]
categories: ["Tech"]
---
# 1.什么是Redis
`Redis`是一个key-value类型的内存数据库吗，整个数据库系统加载在内存中进行操作，并定期通过异步操作把数据库数据`flush`到硬盘上进行保存。

# 2.Redis的数据类型
1. stirng: **字符串**
2. list: **可重复的集合**
3. set: **不可重复的集合**
4. hash: **类似Map<String,String>**
5. zset: **可以排序的set**

# 3.一个字符串类型的value能存储的最大容量是多少
512MB

# 4.怎么理解Redis事务？
`Redis`无法做到关系型数据库（诸如MySQL）一样严格的ACID属性。

为了效率，`Redis`舍弃了事务控制过程中的回滚支持。

一个队列中的多个命令除非是在加入队列时发现错误会做到整个事务都不执行，否则所有命令都会执行，哪怕是队列中有的命令会执行失败。

在配合`wacth`命令后，`Redis`的事务可以实现乐观锁的效果：一个队列中的命令在执行时如果检测到碰撞，则放弃自己的操作。
> 关于watch命令：watch命令可以监控一个或多个键，一旦其中一个键被修改或删除，之后的事务就不会执行。监控一直持续到exec命令（事务中的命令是在exec之后才执行的，所以multi命令可以修改watch监控的键值）。

# 5.Redis事务相关的命令有哪几个？过期时间和永久有效如何设置？
1. 事务相关的命令：
`multi`，
`exec`，
`discard`，
`watch`
2. 过期时间和永久有效：
`expire`和`persist`

# 6.Redis缓存怎么做扩容？
如果`Redis`被当做缓存使用，使用一致性哈希实现动态扩容缩容。

# 7.为什么Redis需要把所有数据放到内存中？
`Redis`为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以`Redis`具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度将会严重影响`Redis`的性能。

如果设置了最大使用内存，则数据已有记录数达到内存限值后，不能继续插入新的值。

# 8.Redis如何做到内存优化？
尽可能使用散列表（hashes)，散列表使用的内存非常小，所以应该尽可能地将你的数据模型抽象到一个散列表里。比如一个用户对象，不要为这个用户的名字、姓氏、邮箱、密码设置单独的`key`，而是应该把这个用户的所有信息存储到一张散列表里面。

# 9.缓存穿透、缓存击穿、缓存雪崩是什么？以及解决方案
1. 缓存穿透：**数据库和缓存都不存在的数据，被大量请求。**
   - **解决方案：** 
     - 1.对空数据进行缓存。
     - 2.使用布隆过滤器。将可能存在的数据`hash`到`bitmap`中，`bitmap`证明该数据不存在则该数据一定不存在；`bitmap`证明改数据存在也只能证明该数据可能存在。该方案只能做到降低发生的概率，无法完全避免。
2. 缓存击穿：**一个被大量请求的数据，缓存突然失效，导致该大量请求直接请求到数据库，造成数据库压力剧增。**
    - **解决方案：** 
      - 1.如果是热点数据，可以设置永不过期。
      - 2.如果数据一定会过期，那可以使用互斥锁，一次只能通过一个请求。
3. 缓存雪崩：**缓存中大量的数据，在同一个时间点、或者较短时间内，全部过期了，导致请求直接请求到数据库，导致数据库压力剧增。**
   - **解决方案：** 
     - 1.如果是热点数据，可以设置永不过期。
     - 2.缓存时间设置一个波动值，避免在同时间内大量的缓存失效。
     - 3.如果有多台`Redis`，可以将热点数据打散分到不同的机器当中。
     - 4.双缓存模式。数据库数据同步到缓存A和B。A设置过期时间，B不设置过期时间。当A为空时去读取B，同时异步去更新缓存，但是更新时需要同时更新2个缓存。

# 10.悲观锁
`Redis`不支持悲观锁。`Redis`作为缓存服务器使用时，以读操作为主，很少写操作，相应的操作被打断的几率较少。不采用悲观锁是为了防止降低性能。

# 11.Redis的持久化
### 1.RDB持久化：
每隔一段时间，将内存中的数据集写到磁盘。

`Redis`会单独创建（`fork`）一个子进程来进行持久化，会先将数据写入到临时文件中，待持久化过程结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任务IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB的方式要比AOF的方式更加高效。

### 2.AOF持久化
以日志的形式记录每个更新操作。`Redis`重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。

**缺点：** 
1. 比起RDB占用更多的磁盘空间。
2. 恢复备份速度要慢。
3. 每次读写都同步的话，有一定的性能压力。
4. 存在个别bug，造成恢复不能。

### 3.总结
**官方推荐：** 如果对数据不敏感，可以单独使用RDB；不建议单独使用AOF，因为可能出现bug；如果只是单纯做纯内存缓存，可以都不用。
   
# 12.Redis是单线程的，为什么那么快？
1. **完全基于内存，绝大部分请求是纯粹的内存操作。** 数据存在内存中，类似于`HashMap`、`HashMap`的优势就是查找和操作的时间复杂度都是O(1)。
2. **数据结构简单**，对数据的操作也简单。`Redis`中的数据结构也是专门进行设计的。
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，也不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。
4. 采用多路I/O复用模型，非阻塞IO。
5. 使用底层模型不同，它们之间底层实现方式以及与客户端直接通信的应用协议不一样，`Redis`直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

# 13.Redis常见性能问题和解决方案
1. Master最好不要做任务持久化工作，比如RDB内存快照和AOF日志文件。
2. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次。
3. 为了主从复制和连接的稳定性，Master和Slave最好在同一个局域网内。
4. 尽量避免在压力很大的主库上增加从库。
5. 主从复制不要用图状结构，用单向链表结构更为稳定。

# 14.Redis的数据淘汰策略
### 1.缓存淘汰策略主要分为3类
1.  `noevition`
2.  `volatile`
3.  `allkeys`

### noevition：
`Redis`的默认策略。只接收读请求，不执行写请求（会直接返回错误）。
### volatile：
**volatile只淘汰设置了过期时间的key。**
1. **volatile-lru：** 根据lru算法淘汰设置了过期时间的key，**lru算法优先删除最近最少使用的key。**
2. **volatile-ttl:** 根据key的过期时间的长短 淘汰设置了过期时间的key，**过期时间越小的key优先被删除。**
3. **volatile-random:** **随机淘汰设置了过期时间的key。**

### allkeys
**allkeys对所有key无差别淘汰**
1. **allkeys-lru:** 根据lru算法淘汰所有的key，**最近最少使用的key优先被删除。**
2. **allkeys-random:** **随机淘汰所有的key。**

# 15.修改配置不重启Redis会实时生效吗？
大部分配置可以通过`config set`命令进行修改，而无需执行任何形式的重启。

